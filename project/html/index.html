<html>
  <head>
    <title>Springformation</title>
    <meta content="">
    <link href="foo.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <center>
      Free Form Deformation with Sprung Control Points <br />
      Alan Richardson <br />
      CMPS 161 Winter 2010
    </center>
    <div>
      <p><h3>Free Form Deformation</h3> Free Form Deformation (hereafter FFD) is a method of reshaping solid models through trivariate tensor product Bernstein 
	polynomials. First proposed as a means of free form solid modeling. The deformation of an object under FFD is defined by a set of control points. In 
	their neutral state, the control points form a regular grid and the object is not deformed. Displacing control points deforms the object by passing the 
	displacement of each point as a coefficient of the Bernstein polynomial. (<a href="p151-sederberg.pdf" title="PDF format">See paper</a> by Thomas W. 
	Sederberg)
      </p>
      <p><h3>Application to Impact Animation</h3>
	This project applies FFD to animate impact deformation on an arbitrary object. This is to be accomplished by connecting the control points through spring
	forces: after an external force displaces a subset of control points, this displacement is propagated over time via spring force throughout the network
	of control points. The resulting deformation of the object over time should resemble an intuitive understanding of impact deformation, albiet without
	necessarily conforming to a strict physical simulation of impact.
      </p>
    </div>
    <div>
      <p><h4>Features</h4>
	The user may provide an arbitrary model, rotate the view around the x, y, and z axes, and zoom the view. User defined impacts are not yet supported; the
	impact is defined in physics::simreset() (see classes, below). A number of sample impacts are provided in comments within that function; for objects whose
	co-ordinates are large numbers it may be appropriate to scale up the values. Displacing the control points before simulation will not produce motion, 
	only initial velocity or acceleration will cause the RK2 simulator (see Implementation Overview) to function. By default both control points and geometry
	are displayed, optionally either or both may be suppressed.
      </p>
      <p><h4>Implementation Overview</h4>
	This program uses tri-cubic bezier splines in place of bernstein polynomials in its implementation of FFD. This requires a 4x4x4 grid of control points.
	These control points are in turn adjusted per frame by a physics simulator class. The physics class integrates position, velocity, and acceleration,
	according to the following equations: 
	<br />p'=v; v'=a; a'=-kv-fa;<br />
	Where k and f are spring and frictional constants, respectively. A second-order Runge-Kutta algorithm is used for integration. Because the acceleration's
	derivative depends on v and a but not p, only initial velocities are accelerations are understood by the physics object. If an initial acceleration is 
	zero, the rest position of the springs are implicitly the initial positions of the control points.
      </p>
    </div>
    <div>
      <p><h4>Class notes</h4>
	<b>GUI</b>: code automatically generated by FLUID; source .fl file included. <br />
	<b>SFDWin</b>: extends FLTK class Fl_Gl_Window. Contains rendering code, raw geometry data. Dynamically allocates FFD and physics objects. KNOWN BUG: Old 
	FFD and physics objects are not always properly cleaned up when loading a new file. <br />
	<b>FFD</b>: Automatically wraps given geometry in a control point mesh when constructed. Contains internal reference to transformed verteces, cached and 
	updated only when necessary. Control point positions may be set with member function setPoint(unsigned,triple), and a const reference to transformed 
	geometry accessed through getOutput(). Note that transformed geometry is only updated, if necessary, during a call to getOutput(). <br />
	<b>physics</b>: Performs RK2 integration on the verteces of an FFD's control point mesh. FFD object must be provided by reference during construction. 
	Presently simulates only hard-coded impacts; if simulation is "reset," the control points are not re-positioned; rather the impact is re-applied to the 
	transformed mesh. The hard-coded impact is found in public member function simreset(). Several alternate pre-defined impacts are provided in comments to
	that function. An impact is defined in terms of initial acceleration and velocity on each control point. <br />
	<b>triple</b>: a simple 3 float vector class. Includes overloads for a number of openGL functions that use 3 floats, multiples of 3 floats. <br />
	<b>glMatrixf</b> and <b>glMatrixd</b>: wrapper classes for arrays of 16 floats or doubles, respectively, supporting a number of openGL operations and 
	matrix multiplication with the triple object (implicitly adopting a w-value of 1).
      </p>
      
      <p><h4>Source code</h4>
	Source files may be found in the following 2 folders: <br />
	<a href="../">project</a> <br />
	<a href="../../shared/">shared</a> <br />
	The makefile in project requires that source files found in shared be in a directory of that name in the same directory as the folder to which you save
	files found in project.
      </p>
    </div>
<div>
  <img src=SFD1.jpeg />
  <img src=SFD2.jpeg />
</div>
</body>
</html>
